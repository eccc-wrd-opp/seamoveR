#' Prepare Ecotone GPS-UHF(+TDR) data for import into Movebank
#'
#' @param data.dir Filepath to the directory containing all Pathtrack data to be
#'  re-formatted. Data must be organized in subfolders by tag-id (e.g. "TagXXXXX"),
#'  as automatically generated by Pathtrack software during download and raw data
#'  processing. All Pathtrack-generated files can be present (.raw, .pos, .txt),
#'  but other user-generated files are not recommended.
#' @param out.dir Filepath to the directory in which to save .csv files of the
#'  Movebank-formatted position data, and TDR data if applicable.
#' @param spcd Four-letter species code to use when generating the .csv filename
#'  for the Movebank-formatted position data, and TDR data if applicable.
#' @param site Colony name/abbreviation (no spaces) to use when generating the
#'  .csv filename for the Movebank-formatted position data, and TDR data if applicable.
#' @param deployLon Longitude of the deployment location, used to replace NA,NA
#'  locations when tag is programmed to stop collecting GPS fixes when in range of
#'  the base station. Required if this setting was used.
#' @param deployLat Longitude of the deployment location, used to replace NA,NA
#'  locations when tag is programmed to stop collecting GPS fixes when in range of
#'  the base station. Required if this setting was used.
#'
#' @details This function compiles the data obtained from Ecotone GPS-UHF tracking
#'  devices (.csv file(s), derived from a .txt base station file using program
#'  NGAnalyzer) into a single file for positional data and a file for time-depth data.
#'  Files are formatted to comply with Movebank's required field names and units.
#'
#' @return Returns an single object if only positional data are present, or a list
#'  of two objects if both positional and time-depth data are present. If out.dir,
#'  spcd, and site are specified, also saves Movebank-formatted data file(s) to
#'  the location specified.
#' @export
#' @importFrom utils read.csv read.table write.csv
formatEcotone <- function(data.dir, outliers00 = T, out.dir = NULL, spcd = NULL, site = NULL, deployLon = NULL, deployLat = NULL) {

  ## Format positional data ##

  # Import and merge all '.csv' files, keep distinct, blanks to NA

  files <- list.files(path = data.dir, pattern = "*.csv", recursive = T)

  dat <- do.call(rbind, lapply(paste0(data.dir, "/", files), read.csv, sep = ";")) |>
    dplyr::distinct() |>
    dplyr::mutate(across(where(is.character), ~ dplyr::na_if(., "")))

  ##? ADD STOP if In.range column has data and deployLat and Lon were not provided! ##

  # Make positional dataset

  pos <- dat |>
    dplyr::filter(!is.na(Longitude) | !is.na(In.range) | !is.na(No.GPS...timeout) | !is.na(No.GPS...diving))

  # Handle NA,NA locations
  # If 'in-range' column has value, replace NA,NA location with deploy location
  # Change remaining NA,NA positions to 0,0 and label ‘import-marked-outlier’ == TRUE.
  # Use the 'outlier-comment' field to say what you did.

  pos <- pos |>
    dplyr::mutate(`import-marked-outlier` = ifelse(is.na(Longitude) & is.na(In.range), TRUE, FALSE),
                  `outlier-comment` = ifelse(!is.na(No.GPS...timeout) , "No GPS, timeout",
                                             ifelse(!is.na(No.GPS...diving), "No GPS, diving",
                                                    ifelse(!is.na(In.range), "In range of base station; changed NA,NA to deployment coordinates", NA))),
                  Longitude = ifelse(!is.na(Longitude), Longitude,
                                     ifelse(!is.na(In.range), deployLon, 0)),
                  Latitude = ifelse(!is.na(Latitude), Latitude,
                                    ifelse(!is.na(In.range), deployLat, 0)))

  # Rename columns and format for Movebank
  # Filter duplicates, sort
  # Didn't keep Additive.Vincentys.Distance.Km., Travel.Speed.Km.h.
  ##? Experimenting with keeping Temperature and PA (Temperature only occurs with coordinates, unlike Temp_sens) ##

  pos <- pos |>
    dplyr::mutate(`sensor-type` = "GPS",
                  timestamp = paste(paste(Year, sprintf("%02d", Month), sprintf("%02d", Day), sep = "-"), paste(sprintf("%02d", Hour), sprintf("%02d", Minute), sprintf("%02d", Second), sep = ":")),
                  `gps-fix-type` = ifelse(!is.na(No.GPS...timeout) | !is.na(No.GPS...diving) | !is.na(In.range), "no fix",
                                          ifelse(!is.na(Altitude), "3D", "2D")),
                  `gps:satellite-count` = ifelse(!is.na(No.GPS...timeout), 0, Sat..Count),
                  `gps-time-to-fix` = Searching.time,
                  `ground-speed` = Speed/1.94384001, # m/s, Ecotone uses kts
                  `location-lat` = Latitude,
                  `location-long` = Longitude,
                  `tag-voltage` = Voltage*1000, # mV not volts
                  `tag-id` = Logger.ID,
                  `external-temperature` = Temperature,
                  `barometric-pressure` = PA) |>
    dplyr::select('sensor-type', 'tag-id',
                  timestamp, 'location-long', 'location-lat',
                  'gps-fix-type', 'gps:satellite-count', 'gps-time-to-fix',
                  'ground-speed', 'tag-voltage',
                  'external-temperature', 'barometric-pressure',
                  'import-marked-outlier', 'outlier-comment') |>
    dplyr::arrange(`tag-id`, timestamp) |>
    dplyr::distinct()

  # Save .csv if required info is provided

  if(!is.null(out.dir) & !is.null(spcd) & !is.null(site)) {

    write.csv(pos, paste0(out.dir, "/posData_", spcd, "_GPS_", site, ".csv"), row.names = F, na = '')

  }


  ## Format TDR data if present ##

  # Occurs within same file as pos data for Ecotone
  ##? Check for Depth or Div.down? Not sure if dive data can exist without there also being depth data ##

  if(length(unique(dat$Depth > 1))){

    # Make TDR dataset
    # Rename columns and format for Movebank

    tdr <- dat |>
      dplyr::filter(dplyr::if_any(c(Div.up, Div.down, PH), ~ !is.na(.))) |>
      dplyr::select(where(~ !all(is.na(.)))) |>
      dplyr::mutate(`barometric-pressure` = ifelse(!is.na(PH), PH, PA), # hPa (mbar)
                    comments = ifelse(!is.na(PH), "hydrostatic pressure",
                                      ifelse(!is.na(PA), "atmospheric pressure", NA)),
                    depth = Depth/100, # meters, Ecotone in cm
                    `sensor-type` = "TDR",
                    timestamp = paste(paste(Year, sprintf("%02d", Month), sprintf("%02d", Day), sep = "-"), paste(sprintf("%02d", Hour), sprintf("%02d", Minute), sprintf("%02d", Second), sep = ":"))) |>
      dplyr::rename(`dive-duration` = Diving.duration,
                    `external-temperature` = Temp_sens,
                    `tag-id` = Logger.ID) |>
      dplyr::select('sensor-type', 'tag-id', timestamp,
                    'dive-duration', 'depth',
                    'barometric-pressure', 'external-temperature',
                    comments) |>
      dplyr::arrange(`tag-id`, timestamp)

    ##? Set atmospheric pressure measurements (Div.up records) to depth = 0 instead of NA?##

    # Collapse rows with identical timestamps
    tdr <- tdr |>
      dplyr::group_by(`sensor-type`, `tag-id`, timestamp) |>
      dplyr::summarise(across(everything(), ~ dplyr::first(na.omit(.))), .groups = "drop")


    # Save .csv if required info is provided

    if(!is.null(out.dir) & !is.null(spcd) & !is.null(site)) {

      write.csv(tdr, paste0(out.dir, "/tdrData_", spcd, "_GPS_", site, ".csv"), row.names = F, na = '')

    }

    # Save pos and tdr as a list
    out_list <- list(
      pos = pos,
      tdr = tdr
    )

    return(out_list)

  } else {

    return(pos)

  }

}
